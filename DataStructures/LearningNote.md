### **稳定性的解释**
```
如果待排序的表中存在多个关键字相同的元素，采用某种排序方法排序后这些具有相同关键字的元素之间的相对次序始终保持不变，则称这种排序方法是稳定的；
反之，若具有相同关键字的元素之间的相对次序发生变化，则称这种排序方法是不稳定的。
```
- [**插入排序**：](#插入排序)
  - [**直接插入排序**：](#直接插入排序)
  - [**折半插入排序算法**](#折半插入排序算法)
  - [**2分希尔排序**](#2分希尔排序)
- [选择排序](#选择排序)
  - [简单选择排序](#简单选择排序)
  - [基于大根堆的堆排序算法](#基于大根堆的堆排序算法)
## **插入排序**：
       
插入排序的基本思想是每一趟将一个待排序的元素按其关键字值的大小插入到已有序的子表中的适当位置，知道全部插入完成。
### **直接插入排序**：
       
直接插入排序的思想是依次将每一个元素插入到有序子表当中，假设元素存放在R[0,n-1]中，R[0,i-1]是已排好的子表（简称为有序区，初始时有序区只有一个元素R[0]），R[i,n-1]是未排序的子表（简称为无序区）。插入排序的过程中将无序区的一个元素有序插入到有序区中，直至无序区为空。

**C语言代码实现：**
```
int directInsertSort(sqlist*sl){
    double tmp;
    for(int i = 1;i<sl->length;i++){
        if(sl->data[i]<sl->data[i-1]){    //反序 这里优化了代码方法，首先通过判断插入元素与有序组最大的元素相比较
           tmp = sl->data[i];   //如果大于，则不用再插入，前i位数组直接为有序组，反之，需要插入，按照比大小的方式进行排序
           int j = i-1;                   //j指向有序组最后的元素
           while(tmp<sl->data[j]&&j>=0){  //不能忽略j>=0，防止数组越界
               sl->data[j+1] = sl->data[j];a
               j--;
           }
           sl->data[j+1] = tmp;
        }
    }
}
```


### **折半插入排序算法**
折半插入排序算法相当于直接插入排序算法优化的部分在于在有序插入时所采取的方法

**C语言代码实现：**
```
int binInsertSort(sqlist* sl){
    for(int i = 1;i<sl->length;i++){
        if(sl->data[i-1]>sl->data[i]){//反序
            double tmp = sl->data[i];
            int low=0,high=i-1,mid=(low+high)/2;
            while(low<=high){
                mid = (low+high)/2;
                if(tmp<sl->data[mid]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }
            for(int j = i;j>high+1;j--){
                sl->data[j] = sl->data[j-1];
            }
            sl->data[high+1] = tmp;
        }
    }
}
```

### **2分希尔排序**
希尔(shell)排序有称为缩小增量排序，其基本思想是把元素按下标的一定增量d(或步长)分组，再对每组元素采用直接插入排序的方法进行排序，然后随着增量逐渐减小，所分成的组包含的元素越来越多，到d值减小到1时，整个数据合成为一组，对该组进行直接插入排序，得到整个有序序列。
**C语言代码实现如下:**
```
int shellSort(sqlist* sl){
    //元素按下标一定增量进行分组，再对每个分组元素采用直接插入排序进行排序
    //首先要想如何进行分组
    int d = sl->length/2;
    while(d>0){
        //sl->length - d为循环次数
        for(int i = d;i<sl->length;i++){
            int tmp = sl->data[i],j = i;
            while(j>=d&&sl->data[j-d]>tmp){//反序
                sl->data[j] = sl->data[j-d];
                j-=d;
            }
            sl->data[j] = tmp;
        }
        d=d/2;
    }
}
```
**值得注意的是无论是几分的希尔排序，最后一次排序的d都必须为1才能保证排序有效**
## 选择排序
选择排序的基本思想是每步从待排序元素中选出关键字最小的元素，顺序放在已排序的元素序列的最后，直到排完为止。
### 简单选择排序
简单选择排序的思想是将数组分为有序区和无序区（类似于插入排序，只不过这里的有序区也相对于**全局有序**），初始时有序区为空，无序区为原数组，从无序区中选取最小的元素放在有序区的末尾，知道无序区为空为止。
**C语言代码实现**
```
int simpleChooseSort(sqlist* sl){
    for(int i = 0;i<sl->length-1;i++){
        int min = sl->data[i];
        int index = i;//注意下标初始值
        for(int j = i+1;j<sl->length;j++){
            if(sl->data[j]<min){
                min = sl->data[j];
                index = j;
            }
        }
        sl->data[index] = sl->data[i];
        sl->data[i] = min;
    }
}
```

### 基于大根堆的堆排序算法
堆的定义：堆是一个顺序存储的完全二叉树，其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为**大根堆**。
如果堆中每个结点的关键字都不大于孩子结点的关键字，这样的堆称为**小根堆**。

（完全二叉树的定义：若二叉树的深度为h，除第h层以外，其他h-1层的结点数都达到了最大个数，并且第h层所有节点都连续集中在最左边）

堆排序的基本思想是首先按照**大根堆的定义将初始序列R[0..n]调整为堆（这个过程称为初始建堆），先交换R[0]和R[n]**（将最大元素R[0]归位，放到排序序列的最后）；

**然后将R[0..n-1]调整为堆，再交换R[0]和R[n-1]**；如此反复，直到只有一个元素，它就是最小元素。

堆排序要多次调用筛选算法。筛选算法的前提是将R[low..high]序列看成是一颗以R[low]为根节点的完全二叉树，其**左子树和右子树均为大根堆，只有根节点不满足大根堆条件**。

依据上述点我们对初始序列进行建堆时也得一步一步来，先从最低分支节点进行建堆；

有了筛选算法与堆排序算法的基本思想，我们就可以设计出堆排序算法；

**C语言代码实现**

*筛选算法*
```
int sift(double* array,int low,int high){
    //在顺序表中，假设树从0开始编号，若双亲结点的序号为i,
    //其左孩子结点的序号为2*i+1,右孩子结点的序号为2*i+2
    int i = low;
    int j = 2*i+1;
    double tmp = array[i];
    while(j<=high){
        if(j<high&&array[2*i+1]<array[2*i+2]){//注意添加j<high条件不然可能会导致数组越界
            j = 2*i+2;//选出子节点值最大的子节点
        }
        if(array[j]>tmp){
            array[i] = array[j];
            i = j;//i在这里表示的是当前父节点,j表示的是当前子节点
            j = 2*i+1;//一定要更新i和j的值，更新j给while循环判断
                      //当时忘了，还是编程能力不强
        }else{
            break;
        }
    }
    array[i] = tmp;
}
```
*堆选择算法*
```
int heapChooseSort(sqlist* sl){
    for(int i = (sl->length-1)/2;i>=0;i--){
        sift(sl->data,i,sl->length-1);//先将整个序列变换成大顶堆
    }
    slPrint(sl);
    //在当时进行编程的时候对于for循环j值的终止条件有误判的点，以前书写的是j>1，还是在编程上对于每一部分实现的意图与真实过程出现了自己的失误，说明了自身编程能力还有待提高
    for(int j = sl->length-1;j>0;j--){
        double tmp = sl->data[0];
        sl->data[0] = sl->data[j];
        sl->data[j] = tmp;
        //以上的目的在于要把大顶堆的根节点与第j个元素进行替换
        //而下面的意义在于将大顶堆前j-1个元素重新进行建堆
        sift(sl->data,0,j-1);
    }
}
```



