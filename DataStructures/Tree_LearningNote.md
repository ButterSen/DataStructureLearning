# 树与二叉树学习笔记

- [树与二叉树学习笔记](#树与二叉树学习笔记)
  - [树的各种基本概念](#树的各种基本概念)
    - [1、树的定义](#1树的定义)
    - [2、树的表示方法](#2树的表示方法)
    - [3、树的基本术语](#3树的基本术语)
      - [（1）结点的度与树的度](#1结点的度与树的度)
      - [（2）分支结点与叶子结点](#2分支结点与叶子结点)
      - [（3）路径与路径长度](#3路径与路径长度)
      - [（4）孩子结点、双亲结点和兄弟结点](#4孩子结点双亲结点和兄弟结点)
      - [（5）结点的层次和树的高度](#5结点的层次和树的高度)
      - [（6）子孙结点](#6子孙结点)
      - [（7）祖先结点](#7祖先结点)
      - [（8）有序树和无序树](#8有序树和无序树)
      - [（9）森林](#9森林)
      - [（10）满m次树](#10满m次树)
      - [（11）完全m次树](#11完全m次树)
    - [树的性质](#树的性质)
    - [树的存储结构](#树的存储结构)
  - [二叉树的基本概念](#二叉树的基本概念)
    - [1、二叉树的定义](#1二叉树的定义)
    - [2、二叉树性质](#2二叉树性质)
    - [3、二叉树与树、森林之间的转换与还原](#3二叉树与树森林之间的转换与还原)
  - [二叉树的存储结构](#二叉树的存储结构)
    - [1、二叉树的顺序存储结构](#1二叉树的顺序存储结构)
    - [2、二叉树的链式存储结构](#2二叉树的链式存储结构)
  - [二叉树的各类算法](#二叉树的各类算法)
    - [使用字符串创建二叉树（链式）](#使用字符串创建二叉树链式)
    - [从顺序表二叉树转换成链式二叉树](#从顺序表二叉树转换成链式二叉树)
    - [随机二叉树的创建](#随机二叉树的创建)
    - [二叉树的基本算法](#二叉树的基本算法)
      - [查找结点](#查找结点)
      - [销毁二叉树](#销毁二叉树)
      - [求二叉树的高度](#求二叉树的高度)

## 树的各种基本概念
### 1、树的定义
树是由n个结点（元素）组成的有限集合（记为T）。如果n=0，它是一棵空树，这是树的特例；如果n>0，这n个结点中存在（有仅存在）一个结点为树的根节点，简称根节点，其余结点可分为m(m>0)个互不相交的有限集$T_1、T_2、...、T_m$，其中每一个子集本身又是一棵符合本定义的树，称为根节点的子树。
树的定义是递归的，因为在树的定义当中又用到了树的定义。它刻画了树的固有特性，即一棵树由若干棵子树构成，而子树又是由更小的子树构成，所以树特别适合表示元素之间的层次关系。
### 2、树的表示方法
树形表示法、文氏图表示法、凹入表示法、括号表示法。
### 3、树的基本术语
#### （1）结点的度与树的度
树中某个结点的子树的个数称为该结点的度。树中度的最大值称为树的度，通常度为m的树称为m次树。
#### （2）分支结点与叶子结点
度不为0的结点称为非终端结点，又称为分支结点。度为0的结点称为终端结点或者说是叶子结点。在分支节点中，每个结点的分支数就是该结点的度，如度为1的结点，其分支数为1，称为单分支结点；对于度为2的结点，其分支数为2，称为双分支结点，以此类推。
#### （3）路径与路径长度
对于任意两个结点$k_i$和$k_j$，若树中存在一个结点序列$k_ik_{i1}k_{i2}...k_{in},k_j$，使得序列中除$k_i$外的任一结点都是其前一个结点的后继结点，则该结点序列为由$k_i$到$k_j$的一条路径，用路径所通过的结点序列($k_ik_{i1}k_{i2}...k_{in},k_j$)可表示这条路径。路径的长度等于路径所通过的分支线的数目。
#### （4）孩子结点、双亲结点和兄弟结点
在一棵树中，每个结点的后继称作该结点的孩子结点。相应地，该结点称为该孩子结点的双亲结点（父结点）。具有同意双亲的孩子结点称为兄弟结点。
#### （5）结点的层次和树的高度
树中每个结点都处在某个层次上，结点的层次从树根开始定义，根结点为第一层，它的孩子结点为第2层，以此类推，一个结点所在层次为其双亲结点所在的层次加1；树中结点的最大层次树为树的高度（或树的深度）。
#### （6）子孙结点
一个结点的子树中除该结点外的所有结点称为该结点的子孙结点
#### （7）祖先结点
从树根结点到达某个结点的路径上通过的所有结点称为该结点的祖先结点（不含该结点本身）。
#### （8）有序树和无序树
若树中各结点的子树是按照一定次序从左向右安排的，且相对次序是不能随便变换的，则称为有序树，否则称为无序树。通常意义上的树指的都是有序树。
#### （9）森林
n$(n\geq0)$个互不相交的树的集合称为森林。森林的概念和树的概念十分相近，因为只要把树的根结点删去就成了森林，反之...
#### （10）满m次树
如果除叶子结点外，其他结点的度均为m，且所有叶子结点均在同一层，这样的树称为满m次树。满m次树可以按层从上到下、同层从左到右遍历，并对层次遍历的次序编号，根结点编号为1，然后依次递增，这称为满m次树的层序编号。对于高度为h的满n次树，结点编号范围为$[1,\frac{m^h-1}{m-1}]$。
#### （11）完全m次树
对于高度为h的满m次树，按满m次树的层序编号后，最高层连续缺少编号最大的若干结点，但最高层中至少有一个结点，这样的树称为高度为h的完全m次树。
### 树的性质
（1）树中的结点数等于所有结点的度之和加1
（2）度为m的树第i层最多有$m^{i-1}$个结点
（3）高度为h的的m次树最多有$\frac{m^i-1}{m-1}$个结点
（4）具有n个结点的m次树的最小高度为$\lceil log_m(n(m-1)-1)\rceil$。
### 树的存储结构
双亲存储结构、孩子链存储结构、孩子兄弟链存储结构
## 二叉树的基本概念
### 1、二叉树的定义
一棵二叉树中含有n($n\geq 0$)个结点，当n=0时，它是一棵空二叉树；当$n\gt 0$时，它由一个根结点和两棵互不相交的称为左子树和右子树的二叉树构成
### 2、二叉树性质
(1)由于二叉树分左右子树，所以由n个结点构成的二叉树共有$\frac{C^n_{2n}}{(n+1)}$
(2)非空二叉树上叶子节点的个数等于双分支结点数加1（通过单分支结点数，叶子结点数与双分支结点数之和等于树的结点数可得）
### 3、二叉树与树、森林之间的转换与还原
(1)树、森林转换为二叉树

将一颗树T转换为二叉树BT的过程归纳如下：

第一步：在所有兄弟结点之间加一条水平连线

第二步：对每个非叶子结点k，除了其最左边的孩子结点（长子）外，删去k与其他孩子结点的连线；
（第三步：将图形规整化）

如果森林中包含多棵树，加上一个虚的根节点，把所有树作为它的子树，这样就变成一棵树，将其转换为一棵二叉树后再删除虚的根节点。（与之相同的步骤：将森林中每棵树分别转换成二叉树，将第二棵转换为二叉树的树作为第一棵转化为二叉树的树的右子结点，第三棵转化为二叉树的树作为第一棵转化为二叉树的树的右子结点，以此类推。

**转换特点**：

1）转换后，左分支仍表示原来的长子关系，右分支表示原来的兄弟关系

2）由于树T中每个非叶子结点对应有一个最右孩子结点，该结点不再有右兄弟，在BT中该结点的右孩子为空。另外，T中根结点在BT中也没有右孩子，所以如果T中由n个分支节点，在BT中由n+1个结点没有右孩子。

3）无论森林中有几棵树，最后都转换成一棵二叉树，第一棵树的根节点作为二叉树的根结点，其余树的结点都作为该结点的右子树中的结点。

（2）二叉树还原为树、森林

若二叉树还有右下结点，将根节点和右下结点都分离为一棵二叉树，然后将每棵根结点没有右孩子结点的二叉树还原为一棵树。

将一棵根结点没有右孩子结点的二叉树还原为一棵树的过程如下：

第一步：对于一棵二叉树的任一结点$k_0$，沿着它的左孩子结点$k_1$的右下方向搜索，即搜索结点序列为$k_0,k_1,...,k_m$，其中$k_{i+1}$为$k_i$的右孩子结点($1\leq i\lt m$)，$k_m$没有右孩子结点。

第二步：删去$k_0,k_1,...,k_m$之间的右分支线；

第三步：连接$k_0$与$k_i(1\leq i\lt m)$；（第四步：规整图形）

**还原后特点**

1)还原后，BT由k个右下结点，T中就有k棵树

2)BT中左分支还原了T中长子关系，右分支还原了T的兄弟关系

## 二叉树的存储结构
### 1、二叉树的顺序存储结构
二叉树的顺序存储结构就是用一组连续地址的存储单元来存放二叉树的结点。其中结点的存放次序是对该树中每个结点进行编号的次序。若把二叉树存储到一维数组中，则该编号就是数组的下标。

二叉树中各结点的编号与等高度的完全二叉树中对应位置上结点的层序编号相同。二叉树的顺序存储结构的定义如下：

typedef ElemType SBTree[MaxSize];//结点从数组1开始存放

根据二叉树的性质，各结点的关系可以由层序编号来决定：对于编号为i的结点，双亲结点存在的情况下编号为$\lfloor i/2 \rfloor$；若存在左孩子结点，则左孩子结点的编号为2i；若存在右孩子结点，则右孩子结点的编号为2i+1。

完全二叉树非常适合采用顺序存储结构进行存储；方便进行查找双亲结点与孩子结点。

但采用顺序存储方式无法适应结点的动态变化，并且当所存储的二叉树不是完全二叉树时，尤其时右斜单支树的时候，空间浪费严重。

### 2、二叉树的链式存储结构
二叉树中每个结点用链表中的一个结点来存储。

一个结点包含数据域、指向左右子结点的指针；这种存储结构称为二叉树链存储结构（简称二叉链）。其结点申明如下：
```C
typedef struct node{
    char data;
    struct node* lchild;
    struct node* rchild;
}BTNode;
```

在这种存储结构下，已知一个结点，很容易访问孩子结点，但对于访问双亲结点需要使用遍历来实现。由于采用链式结构来存储二叉树，该存储结构适合结点的删除和插入，即适合与结点的动态变化。

## 二叉树的各类算法
### 使用字符串创建二叉树（链式）
利用二叉树的括号表示法构建出二叉树的链式存储结构；

对于输入字符串的每个字符，可以分成以下几种情况：

1）如果遇到'(',则对前面的双亲结点进行入栈操作，并置k=1，表示其后创建的结点将作为这个结点的左孩子结点；

2)如果遇到')',则栈中结点的孩子结点处理完毕，进行出栈；

3)如果遇到',',表示其后的结点为右子结点，置k=2；

4)其他情况，表示要创建一个结点，根据k值建立其与栈顶结点之间的联系，当k=1时，表示这个结点作为栈顶结点的左子节点，k=2时表示这个结点作为栈顶结点的右子结点；如此循环，直至处理完毕；

**C语言程序实现**
```C
BTNode* createBTreeByParentheses(char* str){
    //k用于标识下一个孩子结点是左孩子结点还是右孩子结点
    //算法缺陷：无法判断给出的是否是标准字符串
    int k = 0,i = 1;
    BTNodeStack* btns = (BTNodeStack*)malloc(sizeof(BTNodeStack));
    initBTNodeStack(btns);
    BTNode* tmp,*root;
    char ch=str[0];
    if(ch!='\0'){tmp = root = createBTNode(ch);}
    else{return NULL;}
    while(ch!='\0'){
        switch(ch){
            case '(':pushBTNode(btns,tmp);k=1;break;
            case ')':popBTNode(btns);break;
            case ',':k=2;break;
            default:
            //左孩子结点
            if(k==1){
                tmp = createBTNode(ch);
                getTopBTNode(btns)->lchild = tmp; 
            }else if(k==2){
                tmp = createBTNode(ch);
                getTopBTNode(btns)->rchild = tmp;
            }
            break;
        }
        ch = str[i++];
    }
    return root;
}
```
### 从顺序表二叉树转换成链式二叉树
以顺序表表示的二叉树转换为链式二叉树：
1、对于输入字符串，计算长度；

2、对于每一个字符(#和\0除外)，进行入栈操作，并搜寻子结点；

3、若子结点下标出界或没有右子结点，则进行出栈操作；

若搜寻到子结点，进行添加，并按照2操作继续；

4、若出栈的结点下标为奇数（即为右子结点），则再进行出栈操作，继续重复4判断。

**C语言代码实现**

```C
BTNode* transArrayToBTree(char*  SBTree){
    //默认顺序表存储二叉树序号是从1开始的
    //空结点用'#'来表示
    if(SBTree==""){return NULL;}
    char ch = SBTree[1];
    //防止树为空或者根结点为空
    if(ch=='\0'||ch == '#'){return NULL;}
    BTNode* root = createBTNode(ch);
    BTNodeStack* btns = (BTNodeStack*)malloc(sizeof(BTNodeStack));
    initBTNodeStack(btns);
    pushBTNode(btns,root);
    int i = 2,len = 0;
    //计算长度的目的是防止在找寻子结点时越界
    while(ch!='\0'){len++;ch = SBTree[len+1];}
    ch = SBTree[i];
    while(1){
        if(i<=len){
            //未出界且左子结点
            if(i%2==0){
                if(ch!='#'){
                    BTNode* lchild = createBTNode(ch);
                    getTopBTNode(btns)->lchild = lchild;
                    pushBTNode(btns,lchild);
                    i = 2*i;
                }else{
                    //查询右子结点
                    i++;
                }
            }
            else{
                if(ch!='#'){
                    BTNode* rchild = createBTNode(ch);
                    getTopBTNode(btns)->rchild = rchild;
                    pushBTNode(btns,rchild);
                    i = 2*i;
                }else{
                    //如果右子结点为空，一直出栈直到左子节点
                    while(i%2==1&&!btnStackEmpty(btns)){
                        popBTNode(btns);
                        i/=2;
                    }
                    //如果最后是根结点
                    if(btnStackEmpty(btns)){return root;}
                    i++;
                }
            }
        }else{
            //若出界，则进行出栈，多增加一步操作是因为存在左子结点越界的情况
            i/=2;
            popBTNode(btns);
            while(i%2==1&&!btnStackEmpty(btns)){
                popBTNode(btns);
                i/=2;
            }
            //如果最后是根结点
            if(btnStackEmpty(btns)){return root;}
            i++;
        }
        ch = SBTree[i];
    }    
}
```

其实有更加简易的方法进行从顺序表二叉树到链式二叉树的转换，我们可以忽略空结点的限制，将空结点当作一个特殊的结点进行处理，只考虑长度限制，进行完全二叉树的建树，最后将空结点进行剔除；但有个缺点，如果树内空结点较多时，对于时间复杂度较高，且在进行剔除操作的时候，仍要进行各种操作（其实剔除的操作与本算法无异），所以本笔记还是采取笔者设计的算法进行随机二叉树的建造；

### 随机二叉树的创建
（本算法并不属于DS要求内容）

利用顺序表二叉树转链式二叉树，创建随机顺序表二叉树再转链式二叉树实现随机二叉树的创建：

1、创建随机数组，确保数组中每个有效字符不会重复，并且数组长度随机；

2、对每个字符按照二叉树的顺序存储结构进行编码；

3、利用转换函数对顺序存储结构进行转换成链式存储结构。

**C语言程序实现**
```C
BTNode* createRandomBTree(){
    double test = (double)rand()/(double)INT_MAX;
    int len = (int)(((double)rand()/(double)RAND_MAX)*26);
    // printf("%d\n",len);
    char str[len+1];
    int prob = 20,random,index = 0;
    for(int i = 0;i<len;i++){
        str[i] = 't';
    }
    str[len] = '\0';
    if(len<2){return NULL;}
    for(int i = 1;i<len;i++){
        if(str[i/2]!='#'){
            random = (double)rand()/(double)RAND_MAX*prob;
            if(random<=prob-2){
                str[i] = 'A'+index;
                index++;
            }else{
                str[i] = '#';
            }
        }else{
            str[i] = '#';
        }
    }
    // printf("%s %d %d",str,index,len);
    return transArrayToBTree(str);
}
```

### 二叉树的基本算法
#### 查找结点
对于给定字符，进行查找并返回其指针，若无此字符，则返回NULL。
**C语言程序实现**

实际上在具体实现上，两者难度一致；需要注意的是，如果一个递归函数中出现两个递归时，要注意对于返回值的处理；

*使用递归实现*
```C
BTNode* findX(BTNode* btn,char c){
    BTNode* p;
    if(btn==NULL){
        return NULL;
    }else if(btn->data==c){
        return btn;
    }else{
        p = findX(btn->lchild,c);
        if(p!=NULL) return p;
        else return findX(btn->rchild,c);
    }
}
```
*使用栈实现*
```C
BTNode* findXVS(BTNode* btn,char c){
    if(btn==NULL){return NULL;}
    BTNodeStack* btns = (BTNodeStack*)malloc(sizeof(BTNodeStack));
    initBTNodeStack(btns);
    pushBTNode(btns,btn);
    while(!btnStackEmpty(btns)){
        BTNode* tmp = popBTNode(btns);
        if(tmp->data==c){
            return tmp;
        }else{
            //入栈子结点
            if(tmp->lchild!=NULL){
                pushBTNode(btns,tmp->lchild);
            }
            if(tmp->rchild!=NULL){
                pushBTNode(btns,tmp->rchild);
            }
        }
    }
    return NULL;
}
```

#### 销毁二叉树
只要结点不为空，就进行销毁，并对其子结点进行销毁；
**C语言程序实现**

*递归实现销毁*
```C
void destoryBTree(BTNode* root){
    if(root!=NULL){
        destoryBTree(root->lchild);
        destoryBTree(root->rchild);
        free(root);
    }
}
```

*栈实现销毁*
```C
void destoryBTreeVS(BTNode* root){
    BTNodeStack* btns = (BTNodeStack*)malloc(sizeof(BTNodeStack));
    initBTNodeStack(btns);
    if(root!=NULL){
        pushBTNode(btns,root);
    }
    while(!btnStackEmpty(btns)){
        BTNode* temp = popBTNode(btns);
        if(temp->lchild!=NULL){
            pushBTNode(btns,temp->lchild);
        }
        if(temp->rchild!=NULL){
            pushBTNode(btns,temp->rchild);
        }
        free(temp);
    }
}
```

#### 求二叉树的高度
求二叉树的高度的基本思想，如果二叉树结点为空，则返回0，如果非空则返回左右子树高度的最大值加1；
**C语言实现**
*递归实现求二叉树的高度*
```C
int getBTreeHeight(BTNode* root){
    if(root==NULL){return 0;}
    else{
        return fmax(getBTreeHeight(root->lchild),getBTreeHeight(root->rchild))+1;
    }
}
```
*栈实现求二叉树的高度*
```C

```


